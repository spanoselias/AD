/* Parser skeleton for processing item-???.xml files. Must be compiled in * JDK 1.5 or above. * * Instructions: * * This program processes all files passed on the command line (to parse * an entire diectory, type "java MyParser myFiles/*.xml" at the shell). * */import java.io.*;import java.text.*;import java.util.*;import org.xml.sax.XMLReader;import org.xml.sax.Attributes;import org.xml.sax.InputSource;import org.xml.sax.helpers.XMLReaderFactory;import org.xml.sax.helpers.DefaultHandler;public class MySAX_Mod extends DefaultHandler{	//This variable is used to store each value that	//the character function is returned	private String value="";	//This variable is used to store the itemID	private int itemID=-1;	//This variable indicate the seller rating	private String selRating="-1.0";	//This variable indicate the seller id	private String sellerID = "";	//The below two variables are used to store	//latitude and longitude	private double latitude = -1.0;	private double longitude=-1.0;	//It indicated if the coordinates are found	private boolean isCoord = false;	//The variable bidRating is used to	//store bidder rating	private String bidRating = "-1.0";	//The variable bidRating is used to	//store bidder ID	private String bidID = "";	//This is a constant variable to store the delimiter	private  static final String DEL="Â¬";	//This variable is used to store the item name	private String itemName="";	//This variable is used to store the first bid of the item	private String firstBid="-1.0";	//This variable is used to store the currently bid of the item	private String currently= "";	//This variable is used to store the started price for the bid	//of the item	private String started ="";	//This variable is used to store the end price for the bid	//of the item	private String ends="";	//This variable is used to store the description of the item	private String descr ="";	//This variable is stored the total number of bids for the	//specific item	private String noOfBids="";	//This variable is used to create a unique id for each country	private int countrID=-1;	//This variable is used to create a unique id for each new category	private int categoryID=0;	//This variable is used to store the category id	private int categoryCounter=0;	//This variable is used to store the category name	private String categoryName="";	//This variable is used to store the country name	private String countryName="";	//This variable is used to store the location name	private String locationName="";	//This is used to create a unique id for each new location	private int locIDCounter = 0;	//This variable is used to store the time of each bid	private String time="";	//This variable is used to store the amount of each bid	private String amount="";	//This variable is used to store the buyPrice of each bid	private String buyPrice = "-1.0";	//This variable is used to check if a bidder is found	private boolean isBidder = false;	//This variable is used to store the location of the bidder	private String bidderLoc = "";	//This variable is used to store the country of the bidder	private String bidderCountry="";	//The below hashmaps and hashsets are used for eliminate	//duplications. In case where it does not needed an asoociated	//value with the key, it is used just a hashset	private HashSet <String> sellers = new HashSet <String>();	private HashSet<String> mapCoor = new HashSet<String>();	private HashMap<String, Integer> mapCountry = new HashMap<String,Integer>();	private HashMap<String,Integer>  mapLocation = new HashMap<String,Integer>();	//The below hashmaps and hashsets are used for eliminate	//duplications. In case where it does not needed an asoociated	//value with the key, it is used just a hashset	private HashSet <String> bidders = new HashSet <String>();	private HashMap<String, Integer> categories = new HashMap<String, Integer>();	private static HashMap<String, String> dateTransfor = new HashMap<String,String>();	private HashSet <String> bid_Country = new HashSet <String>();	private HashSet <String> bid_Loc = new HashSet <String>();    public static void main (String args[])	throws Exception    {		dateTransfor.put("Jan" , "01");		dateTransfor.put("Feb" , "02");		dateTransfor.put("Mar" , "03");		dateTransfor.put("Apr" , "04");		dateTransfor.put("May" , "05");		dateTransfor.put("Jun" , "06");		dateTransfor.put("Jul" , "07");		dateTransfor.put("Aug" , "08");		dateTransfor.put("Sep" , "09");		dateTransfor.put("Oct" , "10");		dateTransfor.put("Nov" , "11");		dateTransfor.put("Dec" , "12");			//The below code is used to find the current directory in order to delete			//all the csv files			String cur_dir = System.getProperty("user.dir");			File folder = new File(cur_dir);			File[] listOfFiles = folder.listFiles();			for (int i = 0; i < listOfFiles.length; i++) {				if (listOfFiles[i].isFile()) {					//System.out.println("File " + listOfFiles[i].getName());					String tempFile = listOfFiles[i].getName();					File fileTemp = new File(tempFile);					String ext = tempFile.substring(tempFile.lastIndexOf(".") + 1);					if (ext.equals("csv")){						fileTemp.delete();					}				}			}		XMLReader xr = XMLReaderFactory.createXMLReader();		MySAX_Mod handler = new MySAX_Mod();		xr.setContentHandler(handler);		xr.setErrorHandler(handler);		// Parse each file provided on the		// command line.		for (int i = 0; i < args.length; i++)		{			FileReader r = new FileReader(args[i]);			xr.parse(new InputSource(r));		}    }    public MySAX_Mod()    {		super();    }    /* Returns the amount (in XXXXX.xx format) denoted by a money-string     * like $3,453.23. Returns the input if the input is an empty string.     */    static String strip(String money) {        if (money.equals(""))            return money;        else {            double am = 0.0;            NumberFormat nf = NumberFormat.getCurrencyInstance(Locale.US);            try { am = nf.parse(money).doubleValue(); }            catch (ParseException e) {                System.out.println("This method should work for all " +                                   "money values you find in our data.");                System.exit(20);            }            nf.setGroupingUsed(false);            return nf.format(am).substring(1);        }    }    ////////////////////////////////////////////////////////////////////    // Event handlers.    ////////////////////////////////////////////////////////////////////    public void startDocument ()    {		//System.out.println("Start document");    }    public void endDocument ()    {		//System.out.println("End document");    }	////////////////////////////////////////////////////////////////////	// START ELEMENT FUNCTION	////////////////////////////////////////////////////////////////////    public void startElement (String uri, String name,			      String qName, Attributes atts)    {		//The below switch is used to identify and handle each name differently. First, the value of the name is collected		//by using the character function and is stored in the value variable. Then, the below switch is used to associated		//each value with the specific name(element)		switch(name)		{			case "Item":				this.itemID = Integer.parseInt(atts.getValue(0));			break;			case "Location":				//We do not know for sure if there are both fields or				//non of them. So, we should check this case.				if (atts.getLength() == 2)				{					this.latitude = Double.parseDouble(atts.getValue(0));					this.longitude = Double.parseDouble(atts.getValue(1));					isCoord  =true;				}			break;			case "Bidder":				this.bidRating = atts.getValue(0);				this.bidID = atts.getValue(1);				this.isBidder  =true;				//The below hashSet is used to check if the bidder is already exist. If already exist,				//there is no need to store is again. As a result, in this way, we eliminate duplicates.				if ( !this.bidders.contains(this.bidID) )				{					this.bidders.add(this.bidID);					createCsvs("Bidder.csv");				}			break;			case "Seller":				this.selRating = atts.getValue(0);				this.sellerID = atts.getValue(1);				//The below hashSet is used to check if the seller is already exist. If already exist,				//there is no need to store is again. As a result, in this way, we eliminate duplicates.				if ( !this.sellers.contains(this.sellerID) )				{					this.sellers.add(this.sellerID);					createCsvs("Seller.csv");				}			break;		}//Switch    }	////////////////////////////////////////////////////////////////////	// END ELEMENT FUNCTION	////////////////////////////////////////////////////////////////////    public void endElement (String uri, String name, String qName)    {		this.value = this.value.trim();		switch (name)		{			case "Location":				if(isBidder)				{					this.bidderLoc = this.value;					//The below hashMap is used to check if the location has already be stored. In case where this is not					//true, we store the location in the hashMap and in the csv file as well.					if(mapLocation.containsKey(bidderLoc) ==false)					{						this.locIDCounter +=1;						int locID = this.locIDCounter;						mapLocation.put(this.bidderLoc, locID);						//write to csv location						createCsvs("location.csv");					}					String tmpBidderLoc = this.bidID + "_" + this.bidderLoc;					//The below hashMap is used to check if the location of the bidder has already be stored. In case where this is not					//true, we store the location in the hashMap and in the csv file as well.					if(!bid_Loc.contains(tmpBidderLoc))					{						bid_Loc.add(tmpBidderLoc);						//write to csv bidder_location (retrieve locid from hashmap)						createCsvs("Bidder_Location.csv");					}				}				else				{					//It is used to store the location name					this.locationName = this.value;					//The below hashMap is used to check if the location has already be stored. In case where this is not					//true, we store the location in the hashMap and in the csv file as well. We check here again about the					//location because we used one table for both the location of the bidder and the item. In this way, we avoid					//to have redundancy					if(!mapLocation.containsKey(this.locationName))					{						this.locIDCounter +=1;						int locCounter = this.locIDCounter;						mapLocation.put(this.locationName, locCounter);						//It is increased the counter each time when new location						//is found						createCsvs("location.csv");					}				}				//It is check if there are coordinates, otherwise we do not				//want to create a table with null values				if(isCoord)				{					String coorTemp = this.mapLocation.get(this.value) +  this.latitude + "_" + this.longitude;					//It is used a hashset to avoid store multiple times the same coordinates with the id.					//So, the key here, it would be a combination of the location id and both coordinates					if(!this.mapCoor.contains(coorTemp))					{						this.mapCoor.add(coorTemp);						createCsvs("Location_Det.csv");					}					isCoord=false;				}			break;			case "Country":				//This if-statement is used to check if the current country is for				//the bidder or for the item				if(isBidder)				{					this.bidderCountry = this.value;					//It is used a hashset to avoid store multiple times the same country					if(!mapCountry.containsKey(bidderCountry))					{						this.countrID +=1;						int countryID = this.countrID;						mapCountry.put(this.bidderCountry, countryID);						//write to csv location						createCsvs("Country.csv");					}					String tmpBidderCountry = this.bidID + "_" + this.bidderCountry;					//It is used a HashSet to avoid store multiple times the same bidder id					//and location					if(!bid_Country.contains(tmpBidderCountry))					{						bid_Country.add(tmpBidderCountry);						//write to csv bidder_location (retrieve locid from hashmap)						createCsvs("Bidder_Country.csv");					}				}				else				{					this.countryName = this.value;					//It is used a HashMap to avoid store multiple times the same country					if(!mapCountry.containsKey(this.countryName))					{						//System.out.println(this.countryName);						this.countrID +=1;						int countryID = this.countrID;						mapCountry.put(this.countryName, countryID);						//It is increased the counter each time when new location						//is found						createCsvs("Country.csv");					}				}			break;			case "Category":				this.categoryName = this.value;				this.categoryName = this.value;				//It is used a HashMap to avoid store multiple times the same category				if ( !this.categories.containsKey(this.categoryName)){					this.categoryCounter +=1;					this.categoryID =this.categoryCounter;					this.categories.put(this.categoryName, this.categoryID);					createCsvs("Category.csv");					createCsvs("Item_Category.csv");				}else				{					this.categoryID = this.categories.get(this.categoryName);					createCsvs("Item_Category.csv");				}			break;			//It is used to store the current amount of the bid			case "Currently":				this.currently = this.value.substring(1);			break;			//It is used to store the buy price of the item if exist			case "Buy_Price":				this.buyPrice = this.value.substring(1);			break;			//It is used to store the first bid			case "First_Bid":				this.firstBid = this.value.substring(1);			break;			//It is used to store the number of bids			case "Number_of_Bids":				this.noOfBids  = this.value;			break;			//It is used to store the name of the item			case "Item":				createCsvs("Item.csv");				if(!buyPrice.equals("-1.0"))				{					createCsvs("Init_Price.csv");					buyPrice = "-1.0";				}			break;			//It is used to store the description of the item			case "Description":				this.descr = this.value;			break;			//Transform the current time of the xml to a valid data format for mysql			case "Ends":				String tokensE[] = this.value.split(" ");				String dateE[] = tokensE[0].split("-");				this.ends  = "20" + dateE[2] + "-" + dateTransfor.get(dateE[0]) + "-" + dateE[1] + " " + tokensE[1];			break;			//Transform the current time of the xml to a valid data format for mysql			case "Started":				String tokensS[] = this.value.split(" ");				String dateS[] = tokensS[0].split("-");				this.started = "20" + dateS[2] + "-" + dateTransfor.get(dateS[0]) + "-" + dateS[1] + " " + tokensS[1];			break;			//It is used to store the amount			case "Amount":				this.amount = this.value.substring(1);			break;			//Transform the current time of the xml to a valid data format for mysql			case "Time":				String tokens[] = this.value.split(" ");				String date[] = tokens[0].split("-");				this.time = "20" + date[2] + "-" + dateTransfor.get(date[0]) + "-" + date[1] + " " + tokens[1];			break;			//It store in the Bid_Act csv the bidder id, item id, amount, time			case "Bid":				createCsvs("Bid_Act.csv");			break;			//It stores the name			case "Name":				this.itemName = this.value;			break;			//It indicates if the bidder if found			case "Bidder":				isBidder = false;			break;		}		//It is clear the value variable		this.value = "";	}	////////////////////////////////////////////////////////////////////	// CHARACTER FUNCTION	////////////////////////////////////////////////////////////////////    public void characters (char ch[], int start, int length)    {		//The below code is used to store the value for each element		for (int i = start; i < start + length; i++)		{			switch (ch[i]) {			case '\\':				break;			case '"':				break;			case '\n':				break;			case '\r':				break;			case '\t':				break;			default:				this.value += ch[i];			break;			}		}    }	////////////////////////////////////////////////////////////////////	// CREATE CSV FUNCTION	////////////////////////////////////////////////////////////////////	public  void createCsvs(String nameCsv)	{		BufferedWriter bw = null;		FileWriter fw = null;		PrintWriter out;		String content = "";		try		{			switch (nameCsv)			{				//The below code is used to create Seller.csv				case "Seller.csv":					content = this.sellerID + DEL + this.selRating + "\n";					fw = new FileWriter("Seller.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);				break;				//The below code is used to create location.csv				case "location.csv":					content = this.mapLocation.get(this.value) + DEL + this.value + "\n";					fw = new FileWriter("location.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);				break;				//The below code is used to create Location_Det.csv				case "Location_Det.csv":					content = this.mapLocation.get(this.value) + DEL + this.longitude  + DEL + this.latitude + "\n";					fw = new FileWriter("Location_Det.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);				break;				//The below code is used to create Country.csv				case "Country.csv":					content = this.mapCountry.get(this.value) + DEL + this.value + "\n";					fw = new FileWriter("Country.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);				break;				//The below code is used to create Category.csv				case "Category.csv":					content = this.categoryID + DEL + this.categoryName + "\n";					fw = new FileWriter("Category.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);					break;				//The below code is used to create Init_Price.csv				case "Init_Price.csv":					content = this.itemID + DEL + this.buyPrice + "\n";					fw = new FileWriter("Init_Price.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);				break;				//The below code is used to create Item_Category.csv				case "Item_Category.csv":					content = this.itemID + DEL + this.categoryID + "\n";					fw = new FileWriter("Item_Category.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);				break;				//The below code is used to create Bidder.csv				case "Bidder.csv":					content = this.bidID + DEL + this.bidRating + "\n";					fw = new FileWriter("Bidder.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);				break;				//The below code is used to create Bid_Act.csv				case "Bid_Act.csv":					content = this.itemID + DEL + this.bidID+ DEL+ this.time + DEL +this.amount + "\n";					fw = new FileWriter("Bid_Act.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);				break;				//The below code is used to create Bidder_Location.csv				case "Bidder_Location.csv":					content = this.bidID + DEL + mapLocation.get(this.bidderLoc) + "\n";					fw = new FileWriter("Bidder_Location.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);				break;				//The below code is used to create Bidder_Country.csv				case "Bidder_Country.csv":					content = this.bidID + DEL + this.mapCountry.get(this.bidderCountry) + "\n";					fw = new FileWriter("Bidder_Country.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);				break;				//The below code is used to create Item.csv				case "Item.csv":					String descTmp = "";					if( this.descr.length() < 4000)					{						 descTmp = this.descr;					}					else					{						descTmp = this.descr.substring(0,4000);					}					content = this.itemID + DEL + this.itemName + DEL + this.firstBid + DEL + this.currently +DEL + this.started + DEL + this.ends + DEL + descTmp + DEL+ this.noOfBids + DEL + this.sellerID + DEL + this.countrID + DEL  + this.mapLocation.get(this.locationName) +  "\n";					fw = new FileWriter("Item.csv", true);					bw = new BufferedWriter(fw);					out = new PrintWriter(bw);					out.print(content);				break;			}		} catch (IOException e)		{			e.printStackTrace();		} finally		 {			try			{				if (bw != null)					bw.close();				if (fw != null)					fw.close();			} catch (IOException ex)			{				ex.printStackTrace();			}		}	}}